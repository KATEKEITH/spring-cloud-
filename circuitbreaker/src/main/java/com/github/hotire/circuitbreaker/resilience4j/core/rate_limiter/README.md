# RateLimiter

## parkNanos

Thread.sleep() 메서드는 현재 실행 중인 스레드를 지정된 시간 동안 일시 중지하고, 다른 스레드에게 실행 기회를 주는 데 사용됩니다.

반면에 ParkNano는 java.util.concurrent 패키지에서 제공되는 인터페이스로, 스레드를 지정된 시간 동안 대기 상태에 둡니다. ParkNano를 호출하면 해당 스레드가 지정된 시간 동안 블록됩니다. 이 시간이 지나면 스레드는 다시 실행됩니다.

또한, Thread.sleep() 메서드는 스레드를 일시 중지하는 동안 해당 스레드가 보유한 모든 모니터 락을 유지하지만, ParkNano는 락을 유지하지 않습니다. 따라서 ParkNano는 일부 다른 스레드와 협업하여 동기화 작업을 수행할 수 있습니다.

결론적으로, Thread.sleep()은 시간 기반의 스레드 일시 중지를 수행하고 ParkNano는 락 기반의 스레드 대기를 수행합니다.


물론입니다!

Thread.sleep()과 ParkNano는 모두 스레드를 일시 중지하는 데 사용되는 메서드입니다. 그러나 이들은 서로 다른 방식으로 동작합니다.

Thread.sleep() 메서드는 현재 실행 중인 스레드를 지정된 시간 (밀리초) 동안 일시 중지합니다. 이 때 스레드가 보유하고 있는 모니터 락을 유지하며 다른 스레드가 해당 락을 얻을 수 없도록 방해합니다. 이는 일시 중지된 스레드가 깨어나면 다른 스레드가 그 보유하고 있던 자원을 사용할 수 없도록 방지하기 위함입니다.

ParkNano 인터페이스는 스레드를 지정된 시간 동안 대기 상태에 둡니다. 이 때 LockSupport 클래스의 parkNanos() 메서드를 사용합니다. 이 메서드는 스레드를 일시 중지시키는 것이 아니라, 대기 상태에 둡니다. 스레드가 대기 상태에 있을 때는 다른 스레드가 해당 스레드를 unpark() 메서드를 호출하여 깨울 수 있습니다. 이 때, unpark() 메서드는 특정 스레드를 지정하여 깨울 수 있습니다.

또한, ParkNano 인터페이스를 사용하면 대기 중인 스레드를 unpark() 메서드로 깨우는 스레드를 지정할 수 있습니다. 이를 통해, 대기 중인 스레드가 특정 이벤트를 기다리면서 다른 스레드와 협업하여 작업을 수행할 수 있습니다.

요약하자면, Thread.sleep()과 ParkNano는 스레드를 일시 중지하는 기능을 수행하지만, Thread.sleep()는 시간 기반으로 스레드를 일시 중지하고, ParkNano는 락 기반으로 스레드를 대기 상태에 둡니다. 또한, ParkNano는 unpark() 메서드로 대기 중인 스레드를 깨울 수 있으며, 이를 통해 다른 스레드와 협업하여 동기화 작업을 수행할 수 있습니다.


Thread.sleep() 메서드는 인터럽트가 발생하면 InterruptedException을 발생시킵니다. 이 예외는 다른 스레드에서 해당 스레드를 인터럽트하고, Thread.sleep() 메서드가 실행 중인 스레드를 일시 중지해야 할 때 발생합니다. 예를 들어, 다른 스레드에서 interrupt() 메서드를 호출하여 Thread.sleep() 메서드를 실행 중인 스레드를 깨울 수 있습니다.

반면에, ParkNano 인터페이스는 InterruptedException을 직접 발생시키지 않습니다. 대신, LockSupport.parkNanos() 메서드를 호출한 스레드는 Thread.interrupted() 메서드를 사용하여 인터럽트 상태를 확인할 수 있습니다. 따라서, ParkNano를 사용할 때는 인터럽트를 처리하기 위해 별도의 예외 처리가 필요하지 않습니다.

즉, Thread.sleep() 메서드는 인터럽트가 발생하면 예외를 발생시키지만, ParkNano는 직접 예외를 발생시키지 않으므로 인터럽트를 처리하기 위한 별도의 예외 처리가 필요하지 않습니다. 그러나 ParkNano를 사용하는 스레드가 Thread.interrupted() 메서드를 사용하여 인터럽트 상태를 확인하고 이에 따라 적절한 작업을 수행해야 합니다.